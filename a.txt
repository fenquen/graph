link user{id:1} to car{color:'red'} by relation usage{number:2}
link car{color:'red'} to wheel{code:6} by relation usage{number:7}

user{id:1} - usage as usage1 -> car - usage as usage2 -> wheel


user id是1的 对应的记录 1条
car color是red的 对应的记录 2条
wheel code是6的 对应的记录 1条




{
    "user": [
        {
            "_id": "0",
            "id": 1,
            "usage": {
                "number": 2,
                "car": [
                    {
                        "_id": "0",
                        "brand": "toyota",
                        "color": "red",
                        "usage": {
                            "number": 7,
                            "wheel": [
                                {
                                    "_id": "0",
                                    "code": 6
                                }
                            ]
                        }
                    },
                    {
                        "_id": "1",
                        "brand": "honda",
                        "color": "red",
                        "usage": {
                            "number": 7,
                            "wheel": [
                                {
                                    "_id": "0",
                                    "code": 6
                                }
                            ]
                        }
                    }
                ]
            }
        }
    ]
}

column的定义要有 nullable
ColumnValue 要有对应null的
parseElement的时候 1+0 会变成1个TextLiteral(1+0) 不对的 已完成
    matchCalcOp不能到collectPendingChars()来处理,需要和mathCmpOp相同应对 已完成
parseExpr要能支持 (a > 0+6 and b=0) 目前的话必须写成 (id > (0+6) and b=0) 完成
parseExpr要能支持 (id in (0,0+6,0+(a+1),)) 完成
parseExpr (((a = 1))) 完成
values (0+2,'a','0') 完成
by usage(a=0+1,d=0) 完成
(a and b or d) 会解析变成 a and (b or d) 不对 应该是 (a and b) or d 完成

使用session来包含多个sql的action成为1个整体的tx
tx的回复
insert的values也要能支持expr 可以使用现有的parseInExpr 完成

要使用binanry的position替换text的lineNum
本身要有4个byte表示长度

select user[id,name](id=1 and 0=6) as user0 -usage(number > 9) as usage0-> car -own(number=1)-> tyre
data要有唯1标识 不能单使用position因为后续update后可能会变动
select的alias不能重复

data要有tx_min tx_max

对相同的两个目标link了相同属性的相同relation 应该如何应对
    应该是相当重调用1遍了update替换掉原来的

要能够应对like

使用binary保存
buffer
walbuffer
databuffer
select 的 order by

普通select的alias

create if not exist

普通表
    本身的rowId -> 内容
    本身的rowId + 下游relation的tableId + relation的rowId -> 0byte
    本身的rowId + 上游relation的tableId + relation的rowId -> 0byte
relation表
    本身的rowId -> 内容
    本身的rowId + src的tableId + 对应table的data的rowId -> 0byte
    本身的rowId + dest的tableId + 对应table的data的rowId -> 0byte

如何应对relink
     a 使用2个 b 变为 a 使用7个 b
     确定了 起点rowId 终点rowId 关系种类 后 再去link相同的关系 显然对关系来说是覆盖的意思了
如何应对 node叛变
     a 喜欢 b  然后  a 撤销 喜欢 b
bitset
30->1->30
p 00001-00007 relation 001 key 07
user表 tableId 01
    d00 user内容
    p00nr02k01
    p00nr02k31

usage表 tableId 02
    d01 usage内容
    p01sn01k00
    p01dn07k02

    d37 usage内容
    p37sn01k00
    p37dn07k03

model表 tableId 07
    d02 model内容
    p02pr02k01

    d03 model内容
    p03pr02k37